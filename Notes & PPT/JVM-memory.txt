
------------------------------------------------------------------------------------------
 VM - memory
 ------------------------------------------------------------------------------------------

    - stack => local variables
    - heap  => objects
    - perm-gen/method-area ( java 7 ) / meta-space ( java 8)  => static variables

 ✔ java.lang.OutOfMemoryError : PermGen

    -XX:PermSize=N
    -XX:MaxPermSize=N


 ✔ Are objects always on the heap ?



------------------------------------------------------------------------------------------
Internal JVM memory optimization 
------------------------------------------------------------------------------------------

 - Ex1.java

 ✔ string constant pool ( scp ) / sting table / hash-table data structure
 ✔ interning string  
    
    - since java-7 , string pool lives in Heap.

------------------------------------------------------------------------------------------
Tuning the JVM 's memory settings
------------------------------------------------------------------------------------------

 - Ex2.java 

 ✔ understanding the size & density of the string pool

    - string pool implemented using HashMap data-structure 

    > java -XX:+PrintStringTableStatistics com.example.Ex2

 ✔ Tuning the size of the string pool

    > java -XX:+PrintStringTableStatistics -XX:StringTableSize=120121 com.example.Ex2
  
 ✔ Tuning the size of the heap

    > java -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal

    > java -XX:MaxHeapSize=600m -XX:+PrintStringTableStatistics -XX:StringTableSize=120121 com.example.Ex2

    > java -XX:InitialHeapSize=1g -XX:+PrintStringTableStatistics -XX:StringTableSize=120121 com.example.Ex2



✔ Shortcut syntax for heap tuning flags

        -XX:+PrintStringTableStatistics
        -XX:StringTableSize=n

        -XX:MaxHeapSize=n            ||  -Xmx
        -XX:InitialHeapSize=n        ||  -Xms

        -XX:+UnlockDiagnosticVMOptions
        -XX:+PrintFlagsFinal


        e.g

        java -Xms1g -Xmx2g -XX:+PrintStringTableStatistics -XX:StringTableSize=120121 com.example.Ex2



------------------------------------------------------------------------------------------
Introduction to Garbage Collection
------------------------------------------------------------------------------------------
 - Ex3.java

✔ What it means when we say Java is a managed language

 - Java works out when objects are no longer needed
 - Garbage collection is the process to free up memory 


✔ How Java knows which objects can be removed from the Heap
    - unreachable objects on heap

 i.e 
        Any object on the heap which cannot be reached 
        through a reference from the stack is 'eligible for garbage collection'


✔ The System.gc() method

    - https://docs.oracle.com/javase/7/docs/api/java/lang/System.html#gc()

✔ Why it's not a good idea to run the System.gc() method

✔ The finalize() method

✔ The danger of using finalize()



------------------------------------------------------------------------------------------
Monitoring the Heap
------------------------------------------------------------------------------------------


✔ Memory leaks
    ✔ Memory leaks shouldn't be possible in java

✔ Soft Leaks - when an object remains referenced when no longer needed

Ex4.java

 > java -Xmx10m com.example.Ex4
 
✔ Introducing (J)VisualVM

✔ Monitoring the size of the heap over time

    > java -Xmx50m com.example.Ex4

✔ Fixing the problem and checking the heap size    


------------------------------------------------------------------------------------------
Analyzing a heap dump    
------------------------------------------------------------------------------------------

✔ Generating Heap Dump

- command line

    -XX:+HeapDumpOnOutOfMemoryError
    -XX:HeapDumpPath=someFilePath

> java -Xmx50m com.examples.Ex4


✔ Viewing Heap Dump    


------------------------------------------------------------------------------------------
garbage collection    
------------------------------------------------------------------------------------------


✔ The "Mark and Sweep" process with compact


✔ "Stop-the-world" pause

        - Stop-the-world means that the JVM is stopping the application
          from running to execute a GC.
        - GC tuning often means reducing this stop-the-world time.

✔ Generational garbage collection

    This garbage collector was created based on the following two hypotheses.

     - Most objects soon become unreachable.
     - References from old objects to young objects only exist in small numbers
        i.e if an object survives it is likely to live forever



     ✔ Heap in HotSpot VM.
        
        - young generation -- "minor GC" 
        - old generation   -- "major GC" (or a "full GC")

    ✔ young generation

        - Eden
        - s0
        - s1


    ✔ Viewing the generations in VisualVM    

        - install Visual GC plugin

    
    ✔ Viewing the heap when there's a soft-leak
    

------------------------------------------------------------------------------------------
garbage collection tuning & selection  
------------------------------------------------------------------------------------------

Ex5.java
 
✔ Monitoring garbage collection

    > java -Xmx20m -verbose:gc com.example.Ex5


✔ Turning off automated heap allocation sizing    

    -XX:-UseAdaptiveSizePolicy

    verify

    > jps
    > jinfo -flag UseAdaptiveSizePolicy <pid>


✔ Tuning garbage collection - old and young allocation    

    -XXNewRatio=n

    > jinfo -flag NewRatio <pid>

    > java -Xmx20m -XX:NewRatio=1 com.examples.Ex5

✔ Tuning garbage collection - survivor space allocation

    -XX:SurvivorRatio=n

    > jinfo -flag SurvivorRatio <pid>

    > java -Xmx20m -XX:NewRatio=1 XX:SurvivorRatio=5 com.example.Ex5

✔ Tuning garbage collection - generations needed to become old

    -XX:MaxTenuringThreshold=n

    > jinfo -flag MaxTenuringThreshold <pid>


--------------------------------------------------------------



✔ choosing garbage collector

    According to JDK 7, there are GC types. 
        
        1. Serial GC  

            - this GC implementation freezes all application threads when it runs.

             > java -XX:+UseSerialGC -jar Application.java

        // JDK 1.6    
        2. Parallel GC  => -XX:+UseParallelGC

            - this uses multiple threads for managing heap space

            -  But it also freezes other application threads while performing GC.

            - If we use this GC, we can specify maximum garbage collection threads and pause time, 
              throughput and footprint (heap size).

            - The numbers of garbage collector threads can be controlled with the command-line option -XX:ParallelGCThreads=<N>.

            - The maximum pause time goal (gap [in milliseconds] between two GC)is specified with the command-line option -XX:MaxGCPauseMillis=<N>.

            > java -XX:+UseParallelGC -jar Application.java

         // JDK 1.7
        3. Concurrent Mark & Sweep GC  (or "CMS") => -XX:+UseConcMarkSweepGC

            - applications using this type of GC respond slower on average
              but do not stop responding to perform garbage collection.

              > java -XX:+UseParNewGC -jar Application.java  

        // JDK 1.9
        4. Garbage First (G1) GC => -XX:+UseG1GC      

             > java -XX:+UseG1GC -jar Application.java


             -XX:ConcGCThreads=N
             -XX:InitiatingHeapOccupancyPercent   


✔ Sting de-duplication

    -XX:UseStringDeDuplication ( only available if using G1)

---------------------------------------------------------------------------------

JVM-gc-tuning.pdf


To diagnose any memory problems, the Garbage Collection log file is the best place to start. It provides several interesting statistics:

When the scavenge (or Young generation) GC ran?
When the full GC ran?
How many scavenge GCs and Full GCs ran? Did they run repeatedly? In what interval?
After the GC process ran, how much memory was reclaimed in Young, Old, and Permanent/Metaspace generations?
How long did the GC run?
How long did JVM pause when Full GC run?
What was the total allocated memory in each generation?
How many objects were promoted to old generation?


How to Generate GC Log File?

-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:<file-path>

