
------------------------------------------------------------------------------------------
 VM - memory
 ------------------------------------------------------------------------------------------

    - stack => local variables
    - heap  => objects
    - perm-gen/method-area ( java 7 ) / meta-space ( java 8)  => static variables


 ✔ java.lang.OutOfMemoryError : PermGen

    -XX:PermSize=N
    -XX:MaxPermSize=N


 ✔ Are objects always on the heap ?



------------------------------------------------------------------------------------------
Internal JVM memory optimization 
------------------------------------------------------------------------------------------

 - Ex1.java

 ✔ string constant pool ( scp )
 ✔ interning string  
    
    - since java-7 , string pool lives in Heap.


------------------------------------------------------------------------------------------
Tuning the JVM 's memory settings
------------------------------------------------------------------------------------------

 - Ex2.java 

 ✔ understanding the size & density of the string pool

    - string pool implemented using HashMap data-structure 

    > java -XX:+PrintStringTableStatistics com.example.Ex2


 ✔ Tuning the size of the string pool

    > java -XX:+PrintStringTableStatistics -XX:StringTableSize=120121 com.examples.Ex2
  
 ✔ Tuning the size of the heap

    > java -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal

    > java -XX:MaxHeapSize=600m -XX:+PrintStringTableStatistics -XX:StringTableSize=120121 com.examples.Ex2

    > java -XX:InitialHeapSize=1g -XX:+PrintStringTableStatistics -XX:StringTableSize=120121 com.examples.Ex2


✔ Shortcut syntax for heap tuning flags

        -XX:+PrintStringTableStatistics
        -XX:StringTableSize=n

        -XX:MaxHeapSize=n            ||  -Xmx
        -XX:InitialHeapSize=n        ||  -Xms

        -XX:+UnlockDiagnosticVMOptions
        -XX:+PrintFlagsFinal


        e.g

        java -Xms1g -Xmx2g -XX:+PrintStringTableStatistics -XX:StringTableSize=120121 com.examples.Ex2



------------------------------------------------------------------------------------------
Introduction to Garbage Collection
------------------------------------------------------------------------------------------

 - Ex3.java

✔ What it means when we say Java is a managed language

 - Java works out when objects are no longer needed
 - Garbage collection is the process to free up memory 


✔ How Java knows which objects can be removed from the Heap

    - unreachable objects on heap

 i.e 
        Any object on the heap which cannot be reached through a reference from the stack
        is 'eligible for garbage collection'


✔ The System.gc() method

    - https://docs.oracle.com/javase/7/docs/api/java/lang/System.html#gc()


✔ Why it's not a good idea to run the System.gc() method


✔ The finalize() method

✔ The danger of using finalize()




------------------------------------------------------------------------------------------
Monitoring the Heap
------------------------------------------------------------------------------------------


✔ Memory leaks
    ✔ Memory leaks shouldn't be possible in java

✔ Soft Leaks - when an object remains referenced when no longer needed

Ex4.java


 > java -Xmx10m com.examples.Ex4



✔ Introducing (J)VisualVM

✔ Monitoring the size of the heap over time

    > java -Xmx50m com.examples.Ex4

✔ Fixing the problem and checking the heap size    


------------------------------------------------------------------------------------------
Analyzing a heap dump    
------------------------------------------------------------------------------------------

✔ Generating Heap Dump

- command line

    -XX:+HeapDumpOnOutOfMemoryError
    -XX:HeapDumpPath=someFilePath

> java -Xmx50m com.examples.Ex4


✔ Viewing Heap Dump    




------------------------------------------------------------------------------------------
garbage collection    
------------------------------------------------------------------------------------------

✔ The "Mark and Sweep" process

✔ "Stop-the-world"

        - Stop-the-world means that the JVM is stopping the application from running to execute a GC.

        - GC tuning often means reducing this stop-the-world time.


✔ Generational garbage collection


    This garbage collector was created based on the following two hypotheses.

     - Most objects soon become unreachable.
     - References from old objects to young objects only exist in small numbers
        i.e if an object survives it is likely to live forever


     ✔ Heap in HotSpot VM.
    
    - young generation -- "minor GC" 
    - old generation   -- "major GC" (or a "full GC")




    ✔ young generation

        - Eden
        - s0
        - s1

    ✔ Viewing the generations in VisualVM    

        - install Visual GC plugin

    
    ✔ Viewing the heap when there's a soft-leak
    




------------------------------------------------------------------------------------------
garbage collection  tuning & selection  
------------------------------------------------------------------------------------------

Ex5.java
 
✔ Monitoring garbage collection


    > java -Xmx20m -verbose:gc com.examples.Ex5


✔ Turning off automated heap allocation sizing    


    -XX:-UseAdaptiveSizePolicy

    verify

    > jps
    > jinfo -flag UseAdaptiveSizePolicy <pid>


✔ Tuning garbage collection - old and young allocation    


    -XXNewRatio=n

    > jinfo -flag NewRatio <pid>

    > java -Xmx20m -XXNewRatio=1 com.examples.Ex5

✔ Tuning garbage collection - survivor space allocation

    -XX:SurvivorRatio=n

    > jinfo -flag SurvivorRatio <pid>

    > java -Xmx20m -XX:NewRatio=1 XX:SurvivorRatio=5 com.examples.Ex5


✔ Tuning garbage collection - generations needed to become old


    -XX:MaxTenuringThreshold=n


    > jinfo -flag MaxTenuringThreshold <pid>




✔ choosing garbage collector


    According to JDK 7, there are GC types. 
        
        1. Serial GC  

            - this GC implementation freezes all application threads when it runs.

             > java -XX:+UseSerialGC -jar Application.java


        2. Parallel GC  => -XX:+UseParallelGC

            - this uses multiple threads for managing heap space

            -  But it also freezes other application threads while performing GC.

            - If we use this GC, we can specify maximum garbage collection threads and pause time, 
              throughput and footprint (heap size).

            - The numbers of garbage collector threads can be controlled with the command-line option -XX:ParallelGCThreads=<N>.

            - The maximum pause time goal (gap [in milliseconds] between two GC)is specified with the command-line option -XX:MaxGCPauseMillis=<N>.

            > java -XX:+UseParallelGC -jar Application.java

        3. Concurrent Mark & Sweep GC  (or "CMS") => -XX:+UseConcMarkSweepGC

            - applications using this type of GC respond slower on average
              but do not stop responding to perform garbage collection.

              > java -XX:+UseParNewGC -jar Application.java  

        4. Garbage First (G1) GC => -XX:+UseG1GC      

             > java -XX:+UseG1GC -jar Application.java




